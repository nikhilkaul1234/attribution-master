# Load libraries 
x <- c('scales', 'gridExtra', 'tidyverse', 'readxl', 'dummies', 'plotly', 'broom')
lapply(x, require, character.only = TRUE)

# Load data
df <- read_csv('jp_map.csv')

# Fit a Diminishing Return Curve to the points
## 1. This function returns the sum of squared error between 
##    the original point and the points derived from the curve suggested
Ufun<-function(x, Spend, Return) {
  predictedReturn = x[2] + (x[1] - x[2])*((Spend^x[3])/(x[4] + (Spend^x[3])))
  errorSq = (predictedReturn - Return)^2
  sumSqError = sum(errorSq)
  return(sumSqError)
}

for (program_plot in unique(df$program)) {
  # Set some parameters
  channelName = program_plot
  
  # If you want to filter your data set, there's a filter for you here
  df_1 <- df %>%
    filter(program == program_plot)
  
  # For an initial plot of the spend vs return data, set the axis length
  maxX = 1.05*max(df_1$Spend)
  maxY = 1.05*max(df_1$total_conversion_value)
  
  # Set up data frame for plotting
  myPlotDataDF = data.frame(Return = df_1$total_conversion_value, Spend = df_1$Spend)
  
  # Create a simple scatter plot with ggplot2
  simpleScatterPlot <- ggplot(myPlotDataDF, aes(x = Spend, y = Return)) +
    geom_point(color="black") +
    theme(panel.background = element_rect(fill = 'grey85'),
          panel.grid.major = element_line(colour = "white")) +
    coord_cartesian(ylim = c(0,maxY), xlim = c(0,maxX)) +
    scale_x_continuous(labels = dollar) +
    scale_y_continuous(labels = comma) + 
    ggtitle(paste(channelName))
  
  print(simpleScatterPlot)
  
  ## 2. Set parameters to 'step through' in part #3
  ##    in the vector c(a,b,c,d):
  ##    a -> The maximum amount of return that an individual spend could achieve over a long term
  ##    b -> The minimum amount of return that an individual spend could achieve over a long term
  ##    c -> Shape of the curve (should probably start at 1)
  ##    d -> The intercept, or an amount of return that's expected when no spend has occurred
  startValVec = c(0,
                  0,
                  1,
                  min(df_1$total_conversion_value))
  minValVec = c(min(df_1$total_conversion_value),
                min(df_1$total_conversion_value)-0.5*min(df_1$total_conversion_value),
                1.001,
                min(df_1$total_conversion_value))
  maxValVec = c(max(df_1$total_conversion_value)*2,
                min(df_1$total_conversion_value),
                2,
                min(df_1$total_conversion_value))
  
  # 3. Optimize the diminishing return curve
  ##  The nlminb() function will find the optimal fit by 
  ##  stepping through the parameters in step 2
  optim.parms<-nlminb(objective=Ufun,start=startValVec,
                      lower=minValVec,
                      upper=maxValVec,
                      control=list(iter.max=10000,eval.max=1000),
                      Spend = df_1$Spend,
                      Return = df_1$total_conversion_value)
  optim.parms
  
  a = optim.parms$par[1]
  b = optim.parms$par[2]
  c = optim.parms$par[3]
  d = optim.parms$par[4]
  
  ## What were the optimal params?
  a
  b
  c
  d
  
  # 4. Plot the diminishing return curve
  ## The points that construct the curve have to be computed:
  
  ## The spend is on the X axis, so we generate 10k X values to plot
  curveDFx = seq(from=0, to=max(df_1$Spend)*2, length.out=1000)
  ## The return is on the Y axis, and those are generated by our optimized function, given the 10k X values
  curveDFy = b+(a-b)*((curveDFx^c)/(d+(curveDFx^c)))
  ## Construct the dataframe to plot
  curveDF = data.frame(Spend = curveDFx, Return = curveDFy)
  
  ## For an initial plot of the spend vs return data, set the axis length
  maxX = 1.05*max(curveDFx, max(df_1$Spend))
  maxY = 1.05*max(curveDFy, max(df_1$total_conversion_value))
  
  ## Assemble the data frames
  myPlotDataDF = data.frame(Return = df_1$total_conversion_value, Spend = df_1$Spend)
  optimLineDF = data.frame(Spend = curveDFx, Return = curveDFy)
  
  # 5. Plot the points and the diminishing return curve
  scatterPlotPlusFit <- ggplot(myPlotDataDF, aes(x = Spend, y = Return)) +
    geom_point(color="black", shape = 16) +
    theme(panel.background = element_rect(fill = 'grey85'),
          panel.grid.major = element_line(colour = "white")) +
    geom_line(data = optimLineDF, aes(x = Spend, y = Return, color = "darkgreen"))  +
    scale_color_manual(labels = "Optimized ADBUDG Fit",values=c('darkgreen')) +
    theme(legend.title=element_blank(), legend.position = "bottom") +
    coord_cartesian(ylim = c(0,maxY), xlim = c(0,maxX)) +
    scale_x_continuous(labels = dollar) +
    scale_y_continuous(labels = comma) + 
    ggtitle(paste(channelName, "Data & Model Fit", sep = " "))
  
  print(scatterPlotPlusFit)
}
  
